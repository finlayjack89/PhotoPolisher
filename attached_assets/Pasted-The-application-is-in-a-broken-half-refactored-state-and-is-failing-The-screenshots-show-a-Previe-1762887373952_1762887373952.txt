The application is in a broken, half-refactored state and is failing. The screenshots show a "Preview Generation Failed" error and a new UI for "AI Floor Detection" that is not correctly wired up.

Root Cause: The app is failing for two reasons:

Broken Uploads: The server routes (e.g., /api/remove-backgrounds, /api/backdrops) are still expecting express.json() payloads, but large file uploads require multipart/form-data. The server also has no multer middleware configured to parse these file uploads, causing all API calls with file data to fail.

Mock Components: The backdrop upload and library features are not functional. BackdropUpload.tsx and BackdropLibrary.tsx are placeholder mock-ups with no real API calls, which is why backdrops are not saving.

We must pivot and fully implement the "AI-Assisted Setup, Subject-Centric Batch" architecture. This plan will fix all bugs and deliver the final, resilient workflow.

Implementation Plan
Please execute the following 5 phases:

Phase 1: Fix All Server-Side File Uploads
This is the most critical blocker. We must fix the server to handle multipart/form-data using multer.

Install multer types: npm i -D @types/multer.

Update server/routes.ts:

Import multer.

Configure multer for in-memory storage: const upload = multer({ storage: multer.memoryStorage(), limits: { fileSize: 25 * 1024 * 1024 } });

Apply upload.single('image') as middleware to the following routes:

/api/remove-backgrounds

/api/backdrops (this one is new)

Create a new route: /api/analyze-backdrop (also with upload.single('image'))

Update the logic inside these routes to read the file from req.file.buffer instead of req.body. For example, in /api/remove-backgrounds:

TypeScript

const image = {
  data: `data:${req.file.mimetype};base64,${req.file.buffer.toString('base64')}`,
  name: req.file.originalname,
};
const result = await removeBackgrounds({ images: [image] });
Update the /api/backdrops (POST) route to read req.file and req.body (for userId, name, etc.) and save to storage.

Update src/lib/api-client.ts:

Create a new function apiUpload<T = any>(endpoint: string, formData: FormData): Promise<T> that sends a POST request with FormData. Do not set the Content-Type header (the browser must do this).

Create a new function removeBackground(file: File) that uses apiUpload, appends the file to FormData, and calls /api/remove-backgrounds.

Create a new function uploadBackdrop(formData: FormData) that uses apiUpload to call /api/backdrops.

Create a new function analyzeBackdrop(formData: FormData) that uses apiUpload to call /api/analyze-backdrop.

Update server/storage.ts:

Add saveFileToMemStorage and getFileFromMemStorage methods to the IStorage interface and MemStorage class to store and retrieve file buffers by their storagePath.

Update server/index.ts:

Add a new GET route /api/get-memstorage-file that takes a path query param. This route must call storage.getFileFromMemStorage(path) and return the raw file buffer with the correct Content-Type. (This is our mock for a real file storage bucket).

Phase 2: Fix Backdrop Upload & Library
Make the backdrop components functional using our new API endpoints.

Update src/components/BackdropUpload.tsx:

In handleUpload, get image dimensions using getImageDimensions.

Create a FormData object. Append image, userId, name, width, and height.

Call the new api.uploadBackdrop(formData) function.

Call onUploadComplete on success.

Update src/components/BackdropLibrary.tsx:

Use useQuery to call api.getBackdrops(user.id).

Create a useEffect that loops through the returned backdrops. For each backdrop, fetch its image data from our new /api/get-memstorage-file?path=${backdrop.storagePath} endpoint, create a URL.createObjectURL(blob), and save it to the imageUrls state.

Ensure the onSelect prop is called with this new blob URL.

Phase 3: Create AI Backdrop Analysis Endpoint
Update server/image-processing/analyze-images.ts:

Export the existing analyzeImages function.

Add a new analyzeBackdrop function that calls analyzeImages but passes a specific requirements prompt: "Analyze this image. Find the main 'floor' surface, excluding vertical 'wall' surfaces. Return a JSON object with one key, 'floorY', representing the vertical center of this floor as a fraction from 0.0 (top) to 1.0 (bottom). Example: { "floorY": 0.85 }."

The analyzeBackdrop function must parse the AI's text response, extract the JSON, and return the { floorY: 0.85 } object (defaulting to 0.75 if parsing fails).

Update server/routes.ts:

Ensure the /api/analyze-backdrop route created in Phase 1 correctly calls this new analyzeBackdrop function.

Phase 4: Implement "Master Setup" UI in BackdropPositioning.tsx
This is the component in your screenshots.

Remove Redundant Props: Remove the rotatedSubjects prop.

Add New Props: Add allSubjects (the full list of files/cutouts for the batch), isPreCut (boolean), and update onPositioningComplete to pass: (backdrop: string, placement: SubjectPlacement, padding: number, aspectRatio: string) => void.

Add New State:

previewCutout: string | null

isPreviewLoading: boolean

isBackdropAnalyzing: boolean

masterPadding: number (default 20)

masterAspectRatio: string (default 'Original')

Fix Preview Failure:

Create a useEffect that runs on mount.

It must call api.removeBackground using allSubjects[0] (if !isPreCut) or read allSubjects[0] as a data URL (if isPreCut).

On success, set setPreviewCutout with the data URL and setIsPreviewLoading(false).

Handle the error: if this call fails, toast the error message from your screenshot and display a "Retry" button.

Implement AI "Snap":

In handleBackdropUpload, after loading the file, set isBackdropAnalyzing(true).

Create a FormData and call api.analyzeBackdrop.

On success, setPlacement(prev => ({ ...prev, y: data.floorY })) to "snap" the preview.

Set isBackdropAnalyzing(false).

Update UI:

Replace the "Product Size" Slider with a new Slider for masterPadding.

Add a ToggleGroup for masterAspectRatio ('Original', '1:1', '4:3', '3:4').

The preview area must show the previewCutout (once loaded) on the backdrop.

Update the "Batch Processing Info" card to reflect the masterPadding and masterAspectRatio state.

Update handleContinue:

This function must now call onPositioningComplete(backdrop, placement, masterPadding, masterAspectRatio).

Phase 5: Implement "Waiting Room" & Fix Compositing
Refactor CommercialEditingWorkflow.tsx:

Remove ImageRotationStep and ShadowGenerationStep from the workflow.

The WorkflowStep type should be: 'analysis' | 'background-removal' | 'positioning' | 'batch-processing' | 'complete'.

After background-removal (Step 2), transition to positioning (Step 3).

After positioning (Step 4), transition to batch-processing (Step 5).

Add state for masterRules and backdrop.

Render the new <BatchProcessingStep /> when currentStep === 'batch-processing'.

Create src/components/BatchProcessingStep.tsx:

This new component receives subjects (the 20 cutouts), backdrop, and masterRules as props.

It must contain the one-by-one async loop logic.

Loop Logic: For each subject:

const cutoutData = subject.backgroundRemovedData (or read file if pre-cut).

const shadowResult = await api.addDropShadow({ images: [{ name, data: cutoutData }] }).

const subjectWithShadow = shadowResult.images[0].shadowedData.

const { width, height } = await getImageDimensions(subjectWithShadow).

const canvasSize = calculateCanvasSize(width, height, masterRules.padding, masterRules.aspectRatio). (Write this client-side util).

const finalImage = await compositeLayers(backdrop, subjectWithShadow, cutoutData, masterRules.placement, canvasSize).

Add finalImage to a results array and update the progress bar.

Include a try/catch for each file so one failure doesn't stop the batch.

When the loop is done, call onComplete(results).

Fix src/lib/canvas-utils.ts (CRITICAL):

Modify compositeLayers to accept the new signature: (backdropUrl: string, subjectWithShadowUrl: string, cleanSubjectUrl: string, placement: SubjectPlacement, outputCanvasSize: { width: number; height: number }).

Fix Crop: Set canvas size to outputCanvasSize.width/height. Draw the backdropUrl using ctx.drawImage with 9 parameters to scale and crop it to fill the canvas (like background-size: cover), aligning its "floor" with placement.y.

Fix Placement: Calculate the subject position based on the outputCanvasSize and masterRules.padding, not placement.scale.

Fix Reflection: Draw the cleanSubjectUrl (flipped) relative to the subject's new calculated position on the final canvas. This will fix the misalignment bug