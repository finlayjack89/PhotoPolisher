Here's the definitive fix for the 504 Gateway Timeout and the missing reflections. We are refactoring the synchronous batch processing into an asynchronous job queue. This is a 6-step implementation.

Execute these changes precisely.

Step 1: Create the Database Table
Navigate to the SQL Console in the Replit environment. Run the following generic PostgreSQL code to create the image_jobs table.

Note: This version is not Supabase-specific and is corrected to work in the standard Replit PostgreSQL environment.

SQL

-- 1. Create a custom type for the job status
CREATE TYPE image_job_status AS ENUM ('pending', 'processing', 'completed', 'failed');

-- 2. Create the main image_jobs table (generic PostgreSQL)
CREATE TABLE public.image_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL, -- We will get this from the auth middleware
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    status image_job_status DEFAULT 'pending' NOT NULL,
    
    -- Input data from the client
    original_image_url TEXT,
    processing_options JSONB,
    
    -- Output data from the server
    final_image_url TEXT,
    error_message TEXT,
    
    -- Optional: for cleaning up old jobs
    expires_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '1 hour'
);

-- 3. Create an index for faster lookups
CREATE INDEX idx_image_jobs_user_id_status ON public.image_jobs(user_id, status);
Step 2: Create the Background Worker
Create a new file at server/image-processing/process-job.ts. This file will contain the detached, server-side logic that runs in the background.

server/image-processing/process-job.ts
TypeScript

// server/image-processing/process-job.ts
import { type Database } from '../../shared/schema';
import { type SupabaseClient } from '@supabase/supabase-js';
import { addDropShadow } from './add-drop-shadow';

// Define the shape of our options
interface ProcessingOptions {
  shadow?: {
    azimuth: number;
    elevation: number;
    spread: number;
    opacity: number;
  };
  reflection?: any; // Server ignores this
}

type AppDatabase = SupabaseClient<Database>;

/**
 * This function runs in the background.
 * It is NOT awaited by the API route.
 * It updates the Supabase table with progress.
 */
export async function processJob(
  jobId: string,
  db: AppDatabase, // Pass the server's Supabase client
  cleanCutoutDataUrl: string, // This is the original_image_url from the job
  options: ProcessingOptions,
) {
  try {
    // 1. Set job to 'processing'
    await db
      .from('image_jobs')
      .update({ status: 'processing' })
      .eq('id', jobId);

    console.log(`[Job ${jobId}] Starting...`);

    // 2. Add shadow
    const shadowOptions = options.shadow || {
      azimuth: 135,
      elevation: 45,
      spread: 10,
      opacity: 0.5,
    };
    
    console.log(`[Job ${jobId}] Adding drop shadow...`);
    const shadowedSubjectUrl = await addDropShadow(
      cleanCutoutDataUrl,
      shadowOptions.azimuth,
      shadowOptions.elevation,
      shadowOptions.spread,
      shadowOptions.opacity,
    );
    console.log(`[Job ${jobId}] Shadow added. Job complete.`);

    // 4. Update job to 'completed'
    await db
      .from('image_jobs')
      .update({
        status: 'completed',
        final_image_url: shadowedSubjectUrl, // This is what the client needs
      })
      .eq('id', jobId);
      
  } catch (error) {
    console.error(`[Job ${jobId}] Processing failed:`, error);
    // 5. Update job to 'failed'
    await db
      .from('image_jobs')
      .update({
        status: 'failed',
        error_message: error instanceof Error ? error.message : 'Unknown error',
      })
      .eq('id', jobId);
  }
}
Step 3: Refactor the Server API Routes
Replace the entire contents of server/routes.ts. This implements the new /api/process-image (create job) and /api/job-status/:id (poll) endpoints.

server/routes.ts
TypeScript

// server/routes.ts
import { Hono } from 'hono';
import { serveStatic } from 'hono/bun';
import { type AppDatabase, getDb } from './db';
import { processJob } from './image-processing/process-job';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { authMiddleware } from './middleware/auth';
import { storageHandler } from './storage';

const app = new Hono();

// --- API Routes ---

// Define input schema for processing
const processImageSchema = z.object({
  original_image_url: z.string(), // This will be the cleanCutoutDataUrl
  processing_options: z.any(),
});

/**
 * NEW ASYNC ENDPOINT
 * Creates a job and returns immediately.
 */
app.post(
  '/api/process-image',
  authMiddleware,
  zValidator('json', processImageSchema),
  async (c) => {
    const db = getDb(c);
    const user = c.get('user');
    const { original_image_url, processing_options } = c.req.valid('json');

    try {
      // 1. Create the job in the database
      const { data: job, error } = await db
        .from('image_jobs')
        .insert({
          user_id: user.id,
          original_image_url,
          processing_options,
          status: 'pending',
        })
        .select('id')
        .single();

      if (error) {
        console.error('Failed to create job:', error);
        throw new Error(error.message);
      }

      const { id: jobId } = job;

      // 2. Start the job in the background (DO NOT AWAIT)
      processJob(jobId, db, original_image_url, processing_options);

      // 3. Return 202 Accepted with the Job ID
      return c.json({ jobId }, 202);
      
    } catch (err) {
      console.error('Error creating job:', err);
      return c.json({ error: 'Failed to create job' }, 500);
    }
  },
);

/**
 * NEW POLLING ENDPOINT
 * Checks the status of a job.
 */
app.get(
  '/api/job-status/:id',
  authMiddleware,
  async (c) => {
    const db = getDb(c);
    const user = c.get('user');
    const jobId = c.req.param('id');

    if (!jobId) {
      return c.json({ error: 'Job ID is required' }, 400);
    }

    try {
      const { data: job, error } = await db
        .from('image_jobs')
        .select('status, final_image_url, error_message')
        .eq('id', jobId)
        .eq('user_id', user.id) // Security: User can only poll their own job
        .single();

      if (error || !job) {
        console.warn(`Job not found or permission error for user ${user.id} on job ${jobId}`);
        return c.json({ error: 'Job not found' }, 404);
      }
      
      return c.json(job);
      
    } catch (err) {
      console.error(`Error fetching job status for ${jobId}:`, err);
      return c.json({ error: 'Failed to fetch job status' }, 500);
    }
  },
);

// --- Storage Upload Route ---
app.post('/api/upload', authMiddleware, ...storageHandler);

// --- Serve Static Assets ---
app.use('/*', serveStatic({ root: './dist' }));
app.use('*', serveStatic({ root: './dist', path: './index.html' }));

export default app;
Step 4: Update the Client-Side API Client
Replace the entire contents of src/lib/api-client.ts to update the client-side functions to call the new job endpoints.

src/lib/api-client.ts
TypeScript

// src/lib/api-client.ts
import { hc } from 'hono/client';
import type app from '../../server/routes';
import { createClient } from '@supabase/supabase-js';
import { type Database } from 'shared/schema';

// Supabase client singleton
let supabase: ReturnType<typeof createClient<Database>>;
export const getSupabase = () => {
  if (!supabase) {
    supabase = createClient<Database>(
      import.meta.env.VITE_SUPABASE_URL!,
      import.meta.env.VITE_SUPABASE_ANON_KEY!,
    );
  }
  return supabase;
};

// Hono client
const client = hc<typeof app>('/');

export const api = {
  /**
   * Uploads a file to Supabase storage.
   */
  uploadFile: async (file: File) => {
    const supabase = getSupabase();
    const {
      data: { session },
    } = await supabase.auth.getSession();
    if (!session) throw new Error('Not authenticated');

    const formData = new FormData();
    formData.append('file', file);

    const res = await client.api.upload.$post(
      { form: formData },
      {
        headers: {
          Authorization: `Bearer ${session.access_token}`,
        },
      },
    );

    if (!res.ok) {
      throw new Error('File upload failed');
    }
    const data = await res.json();
    return data.url;
  },

  /**
   * Refactored: Starts the server-side processing job.
   * @returns {jobId: string}
   */
  processImage: async (
    original_image_url: string, // This is the cleanCutoutDataUrl
    processing_options: any,
  ): Promise<{ jobId: string }> => {
    const supabase = getSupabase();
    const {
      data: { session },
    } = await supabase.auth.getSession();

    if (!session) throw new Error('Not authenticated');

    const res = await client.api['process-image'].$post(
      {
        json: { original_image_url, processing_options },
      },
      {
        headers: {
          Authorization: `Bearer ${session.access_token}`,
        },
      },
    );

    if (res.status === 202) {
      return res.json();
    }
    
    // Handle errors
    const errorData = await res.json().catch(() => ({ error: 'Processing request failed' }));
    throw new Error(errorData.error || 'Failed to start processing');
  },

  /**
   * New: Polls for job status.
   */
  getJobStatus: async (
    jobId: string,
  ): Promise<{
    status: 'pending' | 'processing' | 'completed' | 'failed';
    final_image_url?: string;
    error_message?: string;
  }> => {
    const supabase = getSupabase();
    const {
      data: { session },
    } = await supabase.auth.getSession();

    if (!session) throw new Error('Not authenticated');
    
    const res = await client.api['job-status'][':id'].$get(
      {
        param: { id: jobId },
      },
      {
        headers: {
          Authorization: `Bearer ${session.access_token}`,
        },
      },
    );

    if (!res.ok) {
      const errorData = await res.json().catch(() => ({ error: 'Job not found' }));
      throw new Error(errorData.error || 'Job not found');
    }
    return res.json();
  },
};
Step 5: Upgrade the Canvas Utility (Reflection Fix)
Replace the entire contents of src/lib/canvas-utils.ts. This is the fix for the missing reflection. compositeLayers now intelligently handles positioning and generates the reflection on the client-side, guaranteeing alignment.

src/lib/canvas-utils.ts
TypeScript

// src/lib/canvas-utils.ts
import { loadImage } from './image-resize-utils';

export type SubjectPlacement = 'bottom-center' | 'bottom-left' | 'bottom-right' | 'middle-center';

// This is the main layer, which is the *shadowed* subject
export interface CompositeLayer {
  url: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface ReflectionOptions {
  opacity: number;
  falloff: number;
}

export interface CompositeOptions {
  outputWidth: number;
  outputHeight: number;
  backdropUrl: string;
  subjectLayer: CompositeLayer;    // The main SHADOWED subject
  cleanSubjectUrl: string;       // The CLEAN subject (for reflection)
  placement: SubjectPlacement;
  paddingPercent: number;          // e.g., 10 for 10%
  reflectionOptions?: ReflectionOptions;
}

/**
 * Gets the dimensions of an image from its URL.
 */
export async function getImageDimensions(
  imageUrl: string,
): Promise<{ width: number; height: number }> {
  try {
    const img = await loadImage(imageUrl);
    return { width: img.naturalWidth, height: img.naturalHeight };
  } catch (error) {
    console.error('Error loading image for dimensions:', error);
    return { width: 0, height: 0 };
  }
}

/**
 * Composites all layers onto a single canvas.
 * This function now calculates final positioning and generates reflections.
 */
export async function compositeLayers(
  options: CompositeOptions,
): Promise<Blob | null> {
  const {
    outputWidth,
    outputHeight,
    backdropUrl,
    subjectLayer,
    cleanSubjectUrl,
    placement,
    paddingPercent,
    reflectionOptions,
  } = options;

  const canvas = document.createElement('canvas');
  canvas.width = outputWidth;
  canvas.height = outputHeight;
  const ctx = canvas.getContext('2d');

  if (!ctx) {
    console.error('Failed to get canvas context');
    return null;
  }

  try {
    // 1. Draw Backdrop
    const backdropImg = await loadImage(backdropUrl);
    ctx.drawImage(backdropImg, 0, 0, outputWidth, outputHeight);

    // 2. Load BOTH subject images
    const [subjectImg, cleanSubjectImg] = await Promise.all([
      loadImage(subjectLayer.url),       // Shadowed
      loadImage(cleanSubjectUrl),      // Clean
    ]);

    // 3. Calculate Final Positioning
    const padding = (outputWidth * paddingPercent) / 100;
    const { width: subjectW, height: subjectH } = subjectLayer;

    let finalX: number, finalY: number;

    switch (placement) {
      case 'bottom-center':
        finalX = (outputWidth - subjectW) / 2;
        finalY = outputHeight - subjectH - padding;
        break;
      case 'bottom-left':
        finalX = padding;
        finalY = outputHeight - subjectH - padding;
        break;
      case 'bottom-right':
        finalX = outputWidth - subjectW - padding;
        finalY = outputHeight - subjectH - padding;
        break;
      case 'middle-center':
        finalX = (outputWidth - subjectW) / 2;
        finalY = (outputHeight - subjectH) / 2;
        break;
      default:
        finalX = (outputWidth - subjectW) / 2;
        finalY = outputHeight - subjectH - padding;
    }
    
    finalX = Math.round(finalX);
    finalY = Math.round(finalY);
    const finalReflectionY = Math.round(finalY + subjectH);


    // 4. Draw Reflection (IF ENABLED)
    if (reflectionOptions && reflectionOptions.opacity > 0) {
      ctx.save();
      
      // Position the reflection
      ctx.translate(finalX, finalReflectionY);
      ctx.scale(1, -1); // Flip vertically

      // Draw the CLEAN subject image flipped
      ctx.drawImage(cleanSubjectImg, 0, 0, subjectW, subjectH);

      // Create fade-out gradient
      const gradient = ctx.createLinearGradient(
        0,
        0,
        0,
        subjectH * reflectionOptions.falloff,
      );
      
      const startOpacity = reflectionOptions.opacity;
      gradient.addColorStop(0, `rgba(255, 255, 255, ${1 - startOpacity})`);
      gradient.addColorStop(1, `rgba(255, 255, 255, 1)`);

      // Apply gradient mask
      ctx.globalCompositeOperation = 'destination-in';
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, subjectW, subjectH);

      ctx.restore();
    }

    // 5. Draw Main Subject (on top of backdrop and reflection)
    ctx.drawImage(subjectImg, finalX, finalY, subjectW, subjectH);

    // 6. Export canvas to blob
    return new Promise((resolve) => {
      canvas.toBlob(resolve, 'image/png');
    });
  } catch (error) {
    console.error('Error during canvas compositing:', error);
    return null;
  }
}
Step 6: Implement the New Batch Processing UI
Replace the entire contents of src/components/BatchProcessingStep.tsx. This is the new UI that orchestrates the async polling, tracks progress, and runs the final client-side compositing.

src/components/BatchProcessingStep.tsx
TypeScript

import React, { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Loader2, ArrowLeft, CheckCircle, AlertCircle, Wand2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { api } from "@/lib/api-client";
import { 
  SubjectPlacement, 
  compositeLayers, 
  getImageDimensions,
  type CompositeOptions,
  type ReflectionOptions
} from "@/lib/canvas-utils";

// Define the subject type
interface Subject {
  name: string;
  originalData?: string;
  backgroundRemovedData?: string;
  size?: number;
  originalSize?: number;
}

interface MasterRules {
  placement: SubjectPlacement;
  padding: number;
  aspectRatio: string;
  // TODO: These should be passed in from ProductConfiguration
  shadowOptions?: any; 
  reflectionOptions?: ReflectionOptions;
}

interface BatchProcessingStepProps {
  subjects: (File | Subject)[];
  backdrop: string;
  masterRules: MasterRules;
  isPreCut: boolean;
  onComplete: (results: Array<{ name: string; compositedData: string }>) => void;
  onBack: () => void;
}

interface ProcessedImage {
  name: string;
  compositedData: string;
}

interface FailedImage {
  name: string;
  error: string;
}

type JobStatus = 'pending' | 'processing' | 'completed' | 'failed';

interface Job {
  name: string;
  jobId: string;
  cleanCutoutData: string; // Store this for final composite
  status: JobStatus;
  final_image_url?: string; // This will be the shadowed_subject_url
  error_message?: string;
}

// Helper to read File as Data URL
const fileToDataUrl = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target?.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

// Client-side crop calculation
const calculateCanvasSize = (
  subjectW: number,
  subjectH: number,
  padding: number,
  aspectRatio: string
) => {
  const paddingPercent = padding / 100;
  
  // 1. Calculate padded subject size
  const paddedW = subjectW / (1 - paddingPercent * 2);
  const paddedH = subjectH / (1 - paddingPercent * 2);

  // 2. Determine final aspect ratio
  let finalAspectRatio: number;
  if (aspectRatio === '1:1') finalAspectRatio = 1;
  else if (aspectRatio === '4:3') finalAspectRatio = 4 / 3;
  else if (aspectRatio === '3:4') finalAspectRatio = 3 / 4;
  else finalAspectRatio = paddedW / paddedH; // 'original'

  // 3. Determine final canvas size
  let canvasW = paddedW;
  let canvasH = canvasW / finalAspectRatio;

  if (canvasH < paddedH) {
    canvasH = paddedH;
    canvasW = canvasH * finalAspectRatio;
  }
  
  return { width: Math.round(canvasW), height: Math.round(canvasH) };
};

export const BatchProcessingStep: React.FC<BatchProcessingStepProps> = ({
  subjects,
  backdrop,
  masterRules,
  isPreCut,
  onComplete,
  onBack,
}) => {
  const [jobs, setJobs] = useState<Job[]>([]);
  const [progress, setProgress] = useState(0);
  const [currentStep, setCurrentStep] = useState("Initializing...");
  const [completedImages, setCompletedImages] = useState<ProcessedImage[]>([]);
  const [failedImages, setFailedImages] = useState<FailedImage[]>([]);
  const { toast } = useToast();
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    startBatchProcessing();

    return () => {
      // Clear interval on component unmount
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  const startBatchProcessing = async () => {
    setCurrentStep(`Starting ${subjects.length} processing jobs...`);
    const newJobs: Job[] = [];
    
    // TODO: These options should be passed in via masterRules
    // from ProductConfiguration -> CommercialEditingWorkflow
    const shadowOptions = { azimuth: 135, elevation: 45, spread: 10, opacity: 0.6 };
    const reflectionOptions = { opacity: 0.4, falloff: 0.5 };
    
    // Store all rules
    masterRules.shadowOptions = shadowOptions;
    masterRules.reflectionOptions = reflectionOptions;

    for (const subject of subjects) {
      const name = (subject as File).name || (subject as Subject).name;
      try {
        // --- Step 1: Get Cutout Data ---
        const cleanCutoutData = isPreCut
          ? await fileToDataUrl(subject as File)
          : (subject as Subject).backgroundRemovedData || '';
        
        if (!cleanCutoutData) throw new Error("Missing cutout data");

        // --- Step 2: Start Async Job ---
        const { jobId } = await api.processImage(cleanCutoutData, {
          shadow: shadowOptions,
        });
        
        newJobs.push({
          name,
          jobId,
          cleanCutoutData,
          status: 'pending',
        });
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        console.error(`Failed to start job for ${name}:`, error);
        setFailedImages(prev => [...prev, { name, error: errorMessage }]);
      }
    }
    
    setJobs(newJobs);
    
    if (newJobs.length === 0) {
      setCurrentStep("No jobs to process.");
      return;
    }
    
    setCurrentStep("Jobs started. Polling for results...");
    
    // Start polling
    intervalRef.current = setInterval(() => {
      pollJobsStatus(newJobs);
    }, 3000); // Poll every 3 seconds
  };

  const pollJobsStatus = async (currentJobs: Job[]) => {
    let completedCount = 0;
    let failedCount = 0;
    let needsUpdate = false;
    const activeJobs = currentJobs.filter(j => j.status === 'pending' || j.status === 'processing');
    
    if(activeJobs.length === 0) {
        if (intervalRef.current) clearInterval(intervalRef.current);
        return;
    }

    for (const job of currentJobs) {
      if (job.status === 'completed' || job.status === 'failed') {
        if (job.status === 'completed') completedCount++;
        if (job.status === 'failed') failedCount++;
        continue;
      }

      // Job is still pending or processing, check its status
      try {
        const statusResult = await api.getJobStatus(job.jobId);
        if (statusResult.status !== job.status) {
          needsUpdate = true;
          job.status = statusResult.status;

          if (statusResult.status === 'completed') {
            job.final_image_url = statusResult.final_image_url;
            completedCount++;
          } else if (statusResult.status === 'failed') {
            job.error_message = statusResult.error_message;
            setFailedImages(prev => [...prev.filter(f => f.name !== job.name), { name: job.name, error: job.error_message || 'Job failed' }]);
            failedCount++;
          }
        }
      } catch (error) {
        console.error(`Error polling job ${job.jobId}:`, error);
        job.status = 'failed';
        job.error_message = (error as Error).message;
        setFailedImages(prev => [...prev.filter(f => f.name !== job.name), { name: job.name, error: job.error_message }]);
        failedCount++;
        needsUpdate = true;
      }
    }
    
    const totalProcessed = completedCount + failedCount;
    setProgress((totalProcessed / jobs.length) * 100);
    setCurrentStep(`Processing... ${totalProcessed} / ${jobs.length} complete.`);

    if (needsUpdate) {
      setJobs([...currentJobs]);
    }

    // Check if all jobs are done
    if (totalProcessed === jobs.length) {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      setCurrentStep("All server processing complete. Compositing images...");
      // Move to final client-side compositing
      finishCompositing(currentJobs);
    }
  };

  const finishCompositing = async (completedJobs: Job[]) => {
    const finalResults: ProcessedImage[] = [];
    
    for (const [index, job] of completedJobs.entries()) {
      if (job.status !== 'completed' || !job.final_image_url) {
        continue; // Skip failed jobs
      }
      
      setCurrentStep(`Compositing ${index + 1} / ${completedJobs.length}: ${job.name}`);
      
      try {
        // --- Step 3: Calculate Crop ---
        const { width, height } = await getImageDimensions(job.final_image_url);
        if (width === 0 || height === 0) throw new Error("Subject dimensions are zero");
        
        const outputCanvasSize = calculateCanvasSize(
          width,
          height,
          masterRules.padding,
          masterRules.aspectRatio
        );
        
        // --- Step 4: Final Composite (Client-side) ---
        const compositeOptions: CompositeOptions = {
          outputWidth: outputCanvasSize.width,
          outputHeight: outputCanvasSize.height,
          backdropUrl: backdrop,
          subjectLayer: {
            url: job.final_image_url, // Shadowed subject
            x: 0, // compositeLayers will calculate x/y
            y: 0,
            width: width,
            height: height
          },
          cleanSubjectUrl: job.cleanCutoutData, // Clean subject
          placement: masterRules.placement,
          paddingPercent: masterRules.padding,
          reflectionOptions: masterRules.reflectionOptions
        };
        
        const finalImageBlob = await compositeLayers(compositeOptions);
        if (!finalImageBlob) throw new Error("Canvas compositing failed");

        const compositedDataUrl = await new Promise<string>((resolve, reject) => {
           const reader = new FileReader();
           reader.onloadend = () => resolve(reader.result as string);
           reader.onerror = reject;
           reader.readAsDataURL(finalImageBlob);
        });
        
        finalResults.push({ name: job.name, compositedData: compositedDataUrl });
        setCompletedImages(prev => [...prev, { name: job.name, compositedData: compositedDataUrl }]);

      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Compositing error";
        console.error(`Failed to composite ${job.name}:`, error);
        setFailedImages(prev => [...prev.filter(f => f.name !== job.name), { name: job.name, error: errorMessage }]);
        toast({
          title: `Failed: ${job.name}`,
          description: errorMessage,
          variant: "destructive",
        });
      }
    }
    
    setCurrentStep("Batch processing complete!");
    // Wait 1 sec before transitioning to gallery
    setTimeout(() => {
      onComplete(finalResults);
    }, 1000);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-background to-secondary/20 flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader className="text-center">
          <div className="flex items-center justify-center gap-2 text-primary mb-2">
            <Wand2 className="h-8 w-8" />
            <CardTitle className="text-2xl">Processing Batch</CardTitle>
          </div>
          <p className="text-muted-foreground">
            Please wait while we generate your images...
          </p>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="flex items-center justify-between text-sm">
              <span className="text-muted-foreground" data-testid="text-current-step">{currentStep}</span>
              <span className="font-medium" data-testid="text-progress-percent">{Math.round(progress)}%</span>
            </div>
            <Progress value={progress} className="h-2" data-testid="progress-batch" />
          </div>

          <div className="flex items-center justify-center gap-2 text-primary">
            <Loader2 className="h-4 w-4 animate-spin" />
            <span className="font-medium">This may take several minutes. Please keep this tab open.</span>
          </div>

          { (jobs.length > 0) &&
            <div className="grid grid-cols-2 gap-4 max-h-48 overflow-y-auto bg-muted/50 p-4 rounded-lg">
              <div className="space-y-2">
                <h4 className="font-medium text-sm">Completed</h4>
                <ul className="text-xs space-y-1 text-green-600">
                  {jobs.filter(j => j.status === 'completed').map((img) => (
                    <li key={img.name} className="flex items-center gap-1.5 truncate" data-testid={`completed-${img.name}`}>
                      <CheckCircle className="h-3 w-3 shrink-0" />
                      <span>{img.name}</span>
                    </li>
                  ))}
                </ul>
              </div>
              <div className="space-y-2">
                <h4 className="font-medium text-sm">Failed</h4>
                <ul className="text-xs space-y-1 text-destructive">
                  {jobs.filter(j => j.status === 'failed').map((img) => (
                    <li key={img.name} className="flex items-center gap-1.5 truncate" data-testid={`failed-${img.name}`}>
                      <AlertCircle className="h-3 w-3 shrink-0" />
                      <span>{img.name}</span>
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          }
          
          <Button variant="outline" onClick={onBack} className="w-full" data-testid="button-cancel-batch">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Setup (This will cancel the batch)
          </Button>
        </CardContent>
      </Card>
    </div>
  );
};
This 6-step refactor is complete. It will resolve the 504 Gateway Timeout and correctly implement client-side reflections.