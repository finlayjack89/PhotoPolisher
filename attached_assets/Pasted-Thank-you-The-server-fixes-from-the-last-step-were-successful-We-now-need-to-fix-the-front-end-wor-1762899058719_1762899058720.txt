Thank you. The server fixes from the last step were successful. We now need to fix the front-end workflow. The app is crashing at the BackdropPositioning step because it's trying to re-run background removal on an image that has already been processed.

We will now fix this bug and implement the remaining Phase 3, 4, and 5 of our architecture.

Phase 3: Fix BackdropPositioning.tsx (The "Master Setup")
Action: Replace the entire contents of src/components/BackdropPositioning.tsx with the code below. This new code:

Fixes the Bug: Correctly reads the backgroundRemovedData from the ProcessedSubject prop instead of calling the API.

Implements AI "Snap": Calls the new /api/analyze-backdrop endpoint to find the floor.

Adds Master Controls: Adds the "Padding" slider and "Aspect Ratio" toggles.

Fixes Preview: Implements a new CSS-based preview that correctly simulates the final "Subject-Centric Crop."

File: src/components/BackdropPositioning.tsx

TypeScript

import React, { useState, useRef, useEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Badge } from "@/components/ui/badge";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import {
  Upload,
  Move,
  ArrowRight,
  AlertCircle,
  Zap,
  Library,
  Loader2,
  ArrowLeft,
} from "lucide-react";
import { SubjectPlacement, getImageDimensions } from "@/lib/canvas-utils";
import { useToast } from "@/hooks/use-toast";
import { BackdropLibrary } from "@/components/BackdropLibrary";
import { api } from "@/lib/api-client";
import { ToggleGroup, ToggleGroupItem } from "@/components/ui/toggle-group";

// Define the type for a processed subject
interface ProcessedSubject {
  name: string;
  originalData: string;
  backgroundRemovedData: string;
  size: number;
  originalSize?: number;
}

interface BackdropPositioningProps {
  allSubjects: (File | ProcessedSubject)[];
  isPreCut: boolean;
  onPositioningComplete: (
    backdrop: string,
    placement: SubjectPlacement,
    padding: number,
    aspectRatio: string,
  ) => void;
  onBack: () => void;
}

// Helper to read File as Data URL
const fileToDataUrl = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target?.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

export const BackdropPositioning: React.FC<BackdropPositioningProps> = ({
  allSubjects,
  isPreCut,
  onPositioningComplete,
  onBack,
}) => {
  const [backdrop, setBackdrop] = useState<string>("");
  const [backdropFile, setBackdropFile] = useState<File | null>(null);
  
  const [previewCutout, setPreviewCutout] = useState<string | null>(null);
  const [isPreviewLoading, setIsPreviewLoading] = useState(true);
  const [isBackdropAnalyzing, setIsBackdropAnalyzing] = useState(false);
  const [previewError, setPreviewError] = useState<string | null>(null);

  // Master Rules State
  const [masterPadding, setMasterPadding] = useState(20);
  const [masterAspectRatio, setMasterAspectRatio] = useState("original");
  
  const [placement, setPlacement] = useState<SubjectPlacement>({
    x: 0.5,
    y: 0.7,
    scale: 1.0, // Scale is now controlled by padding
  });

  const fileInputRef = useRef<HTMLInputElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const { toast } = useToast();

  const [subjectDimensions, setSubjectDimensions] = useState({ w: 1, h: 1 });
  const [backdropDimensions, setBackdropDimensions] = useState({ w: 1, h: 1 });
  const [aiFloorY, setAiFloorY] = useState<number | null>(null);

  // This effect fetches the preview cutout
  useEffect(() => {
    const getPreviewCutout = async () => {
      if (!allSubjects || allSubjects.length === 0) {
        setPreviewError("No subjects found to preview.");
        setIsPreviewLoading(false);
        return;
      }
      
      const firstSubject = allSubjects[0];
      setPreviewError(null);
      setIsPreviewLoading(true);

      try {
        let cutoutData: string;

        // --- THIS IS THE BUG FIX ---
        if (isPreCut) {
          // Subject is a File, we need to read it
          console.log("Loading pre-cut preview...");
          cutoutData = await fileToDataUrl(firstSubject as File);
        } else {
          // Subject is an object, we just get the data
          console.log("Loading processed cutout preview...");
          cutoutData = (firstSubject as ProcessedSubject).backgroundRemovedData;
        }
        // --- END BUG FIX ---

        if (!cutoutData) throw new Error("Cutout data is empty.");

        setPreviewCutout(cutoutData);
        const dims = await getImageDimensions(cutoutData);
        setSubjectDimensions({ w: dims.width, h: dims.height });
      } catch (error) {
        console.error("Preview Generation Error:", error);
        setPreviewError("Could not load preview cutout. Please go back and retry.");
      } finally {
        setIsPreviewLoading(false);
      }
    };
    getPreviewCutout();
  }, [allSubjects, isPreCut]);

  // This effect updates the backdrop dimensions
  useEffect(() => {
    if (backdrop) {
      getImageDimensions(backdrop).then(dims => {
        setBackdropDimensions({ w: dims.width, h: dims.height });
      });
    }
  }, [backdrop]);

  const handleBackdropUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setBackdropFile(file);
      setIsBackdropAnalyzing(true);
      setAiFloorY(null);
      setBackdrop(""); // Clear old backdrop

      try {
        const dataUrl = await fileToDataUrl(file);
        setBackdrop(dataUrl);

        // Call AI Floor Detection
        const formData = new FormData();
        formData.append('image', file);
        const { floorY } = await api.analyzeBackdrop(formData);
        
        setAiFloorY(floorY);
        setPlacement(prev => ({ ...prev, y: floorY }));
        toast({
          title: "AI Floor Detection",
          description: `Floor snapped to ${Math.round(floorY * 100)}%`,
        });

      } catch (error) {
        console.error('Error analyzing backdrop:', error);
        toast({
          title: "AI Analysis Failed",
          description: "Defaulting to 75%. You can position it manually.",
          variant: "destructive"
        });
        setAiFloorY(0.75);
        setPlacement(prev => ({ ...prev, y: 0.75 }));
      } finally {
        setIsBackdropAnalyzing(false);
      }
    }
  };

  const handleLibrarySelect = async (backdrop: any, imageUrl: string) => {
    setIsBackdropAnalyzing(true);
    setAiFloorY(null);
    setBackdrop(imageUrl); // Set preview from blob URL
    
    try {
      // Convert the blob URL back to a File to send to analysis
      const response = await fetch(imageUrl);
      const blob = await response.blob();
      const file = new File([blob], backdrop.name, { type: blob.type });
      setBackdropFile(file);

      const formData = new FormData();
      formData.append('image', file);
      const { floorY } = await api.analyzeBackdrop(formData);

      setAiFloorY(floorY);
      setPlacement(prev => ({ ...prev, y: floorY }));
      toast({
        title: "Backdrop Selected",
        description: `Using "${backdrop.name}" and snapped floor to ${Math.round(floorY * 100)}%`,
      });
    } catch (error) {
      console.error('Error selecting/analyzing library backdrop:', error);
      toast({
        title: "Error",
        description: "Failed to analyze backdrop. Defaulting to 75%.",
        variant: "destructive"
      });
      setAiFloorY(0.75);
      setPlacement(prev => ({ ...prev, y: 0.75 }));
    } finally {
      setIsBackdropAnalyzing(false);
    }
  };

  const handleContinue = () => {
    if (backdrop) {
      onPositioningComplete(backdrop, placement, masterPadding, masterAspectRatio);
    }
  };

  // --- Start CSS Preview Logic ---
  const getPreviewStyles = () => {
    if (!backdrop || !previewCutout) return {};

    const padding = masterPadding / 100;
    const { w: subjectW, h: subjectH } = subjectDimensions;
    if (subjectW <= 1 || subjectH <= 1) return {};

    // 1. Calculate padded subject size
    const paddedW = subjectW / (1 - padding * 2);
    const paddedH = subjectH / (1 - padding * 2);

    // 2. Determine final aspect ratio
    let finalAspectRatio = backdropDimensions.w / backdropDimensions.h;
    if (masterAspectRatio === '1:1') finalAspectRatio = 1;
    else if (masterAspectRatio === '4:3') finalAspectRatio = 4 / 3;
    else if (masterAspectRatio === '3:4') finalAspectRatio = 3 / 4;
    else if (masterAspectRatio === 'original') {
      finalAspectRatio = paddedW / paddedH;
    }

    // 3. Determine final "virtual" canvas size
    let canvasW = paddedW;
    let canvasH = canvasW / finalAspectRatio;
    if (canvasH < paddedH) {
      canvasH = paddedH;
      canvasW = canvasH * finalAspectRatio;
    }
    
    // 4. Calculate scaling factor to fit preview in 500px container
    const previewContainerWidth = 500;
    const scaleFactor = Math.min(1, previewContainerWidth / canvasW);
    const previewW = canvasW * scaleFactor;
    const previewH = canvasH * scaleFactor;

    // 5. Calculate subject size *inside* the preview container
    const subjectPreviewW = subjectW * scaleFactor;
    const subjectPreviewH = subjectH * scaleFactor;

    // 6. Calculate backdrop styles (the "zoom")
    // This logic mimics CSS "background-size: cover"
    const canvasAspect = canvasW / canvasH;
    const backdropAspect = backdropDimensions.w / backdropDimensions.h;
    
    let backdropSize, backdropX, backdropY;
    
    if (backdropAspect > canvasAspect) { // Backdrop is wider
      backdropSize = `auto ${100 / (canvasH / backdropDimensions.h)}%`;
      const backdropWidth = backdropDimensions.w * (previewH / backdropDimensions.h);
      const offsetX = (backdropWidth - previewW) * placement.x;
      backdropX = `${-offsetX}px`;
      backdropY = '0px';
    } else { // Backdrop is taller
      backdropSize = `${100 / (canvasW / backdropDimensions.w)}% auto`;
      const backdropHeight = backdropDimensions.h * (previewW / backdropDimensions.w);
      const offsetY = (backdropHeight - previewH) * placement.y;
      backdropX = '0px';
      backdropY = `${-offsetY}px`;
    }

    return {
      previewContainerStyles: {
        width: `${previewW}px`,
        height: `${previewH}px`,
      },
      backdropStyles: {
        backgroundImage: `url(${backdrop})`,
        backgroundSize: backdropSize,
        backgroundPosition: `${backdropX} ${backdropY}`,
      },
      subjectStyles: {
        width: `${subjectPreviewW}px`,
        height: `${subjectPreviewH}px`,
        left: `50%`,
        top: `${placement.y * 100}%`, // Position based on drag
        transform: 'translate(-50%, -50%)',
      }
    };
  };
  
  const { previewContainerStyles, backdropStyles, subjectStyles } = getPreviewStyles();
  // --- End CSS Preview Logic ---

  return (
    <div className="min-h-screen bg-background p-4">
      <div className="max-w-6xl mx-auto space-y-6">
        <div className="text-center space-y-4">
          <div className="flex items-center justify-center gap-2 text-primary">
            <Move className="h-8 w-8" />
            <h1 className="text-3xl font-bold">Master Configuration</h1>
          </div>
          <p className="text-muted-foreground max-w-2xl mx-auto">
            Set up backdrop, positioning, and output settings for batch processing.
          </p>
        </div>

        <div className="grid lg:grid-cols-2 gap-6">
          {/* Left Panel - Controls */}
          <Card>
            <CardHeader>
              <CardTitle>Master Configuration</CardTitle>
              <CardDescription>
                Set backdrop, positioning, and output settings for batch processing
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="space-y-2">
                <Label>Backdrop Image *</Label>
                <Tabs defaultValue="upload" className="w-full">
                  <TabsList className="grid w-full grid-cols-2">
                    <TabsTrigger value="upload">Upload New</TabsTrigger>
                    <TabsTrigger value="library">From Library</TabsTrigger>
                  </TabsList>
                  
                  <TabsContent value="upload" className="mt-4">
                    <div 
                      className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-6 text-center cursor-pointer hover:border-primary/50 transition-colors"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <Upload className="h-8 w-8 mx-auto mb-2 text-muted-foreground" />
                      <p className="text-sm text-muted-foreground">
                        {backdrop ? (backdropFile ? backdropFile.name : "Library Backdrop Selected") : "Click to upload backdrop"}
                      </p>
                    </div>
                    <input
                      ref={fileInputRef}
                      type="file"
                      accept="image/*"
                      onChange={handleBackdropUpload}
                      className="hidden"
                    />
                  </TabsContent>
                  
                  <TabsContent value="library" className="mt-4">
                    <BackdropLibrary 
                      selectionMode={true}
                      onSelect={handleLibrarySelect}
                    />
                  </TabsContent>
                </Tabs>
              </div>

              {/* New Controls */}
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label>Padding</Label>
                  <Slider
                    value={[masterPadding]}
                    onValueChange={(val) => setMasterPadding(val[0])}
                    max={50}
                    min={5}
                    step={1}
                  />
                  <div className="text-xs text-muted-foreground text-center">
                    {masterPadding}% (Space around subject)
                  </div>
                </div>
                <div className="space-y-2">
                  <Label>Final Aspect Ratio</Label>
                  <ToggleGroup
                    type="single"
                    value={masterAspectRatio}
                    onValueChange={(val) => val && setMasterAspectRatio(val)}
                    className="grid grid-cols-4"
                  >
                    <ToggleGroupItem value="original">Original</ToggleGroupItem>
                    <ToggleGroupItem value="1:1">1:1</ToggleGroupItem>
                    <ToggleGroupItem value="4:3">4:3</ToggleGroupItem>
                    <ToggleGroupItem value="3:4">3:4</ToggleGroupItem>
                  </ToggleGroup>
                </div>
              </div>

              {/* AI Floor Detection */}
              <div className="flex items-center space-x-2">
                <Zap className="h-4 w-4 text-primary" />
                <Label>AI Floor Detection Active</Label>
                {isBackdropAnalyzing ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <Badge variant={aiFloorY ? "default" : "secondary"}>
                    {aiFloorY ? `${Math.round(aiFloorY * 100)}%` : "N/A"}
                  </Badge>
                )}
              </div>

              {/* Batch Info */}
              <Card>
                <CardHeader className="pb-3">
                  <CardTitle className="text-base">Batch Processing Info</CardTitle>
                </CardHeader>
                <CardContent className="text-sm space-y-1 text-muted-foreground">
                  <div className="flex justify-between">
                    <span>Total images to process:</span>
                    <span>{allSubjects.length}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Backdrop:</span>
                    <span className={backdrop ? 'text-green-600' : 'text-destructive'}>{backdrop ? "‚úì Ready" : "‚ö† Required"}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Preview:</span>
                    <span className={isPreviewLoading ? 'text-yellow-600' : (previewCutout ? 'text-green-600' : 'text-destructive')}>
                      {isPreviewLoading ? "‚ö† Loading" : (previewCutout ? "‚úì Ready" : "‚ùå Failed")}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span>Padding:</span>
                    <span>{masterPadding}%</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Aspect Ratio:</span>
                    <span className="capitalize">{masterAspectRatio}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>AI Floor Detection:</span>
                    <span className={isBackdropAnalyzing ? 'text-yellow-600' : (aiFloorY ? 'text-green-600' : 'text-muted-foreground')}>
                      {isBackdropAnalyzing ? "..." : (aiFloorY ? `‚úì Active (${Math.round(aiFloorY * 100)}%)` : "N/A")}
                    </span>
                  </div>
                </CardContent>
              </Card>

            </CardContent>
          </Card>

          {/* Right Panel - Preview */}
          <Card>
            <CardHeader>
              <CardTitle>Preview</CardTitle>
              <CardDescription>
                Drag to set vertical position. Padding and aspect ratio are applied.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="flex items-center justify-center p-4">
                {previewError ? (
                  <div className="text-center text-destructive">
                    <AlertCircle className="h-12 w-12 mx-auto mb-2" />
                    <p className="font-medium">Preview Generation Failed</p>
                    <p className="text-sm">{previewError}</p>
                    <Button onClick={onBack} variant="outline" size="sm" className="mt-4">
                      Go Back
                    </Button>
                  </div>
                ) : !backdrop ? (
                  <div className="flex items-center justify-center h-64 text-center text-muted-foreground">
                    <div>
                      <Upload className="h-12 w-12 mx-auto mb-2" />
                      <p>Upload backdrop to see preview</p>
                    </div>
                  </div>
                ) : isPreviewLoading ? (
                  <div className="flex items-center justify-center h-64 text-center text-muted-foreground">
                    <div>
                      <Loader2 className="h-12 w-12 mx-auto mb-2 animate-spin" />
                      <p>Loading preview cutout...</p>
                    </div>
                  </div>
                ) : (
                  <div
                    className="relative max-w-full overflow-hidden rounded-lg border-2 border-primary/50"
                    style={previewContainerStyles}
                    onMouseDown={(e) => {
                      const rect = e.currentTarget.getBoundingClientRect();
                      setIsDragging(true);
                      setDragStart({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseMove={(e) => {
                      if (!isDragging) return;
                      const rect = e.currentTarget.getBoundingClientRect();
                      setPlacement(prev => ({
                        ...prev,
                        x: 0.5, // X is always 50%
                        y: Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height))
                      }));
                    }}
                    onMouseUp={() => setIsDragging(false)}
                    onMouseLeave={() => setIsDragging(false)}
                  >
                    <div 
                      className="absolute inset-0"
                      style={backdropStyles}
                    />
                    
                    <div
                      className="absolute cursor-move select-none"
                      style={subjectStyles}
                    >
                      <img
                        src={previewCutout || ''}
                        alt="Product Preview"
                        className="w-full h-auto select-none"
                        draggable={false}
                      />
                    </div>
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        <div className="flex justify-between">
          <Button variant="outline" onClick={onBack}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back
          </Button>
          <Button 
            onClick={handleContinue} 
            disabled={!backdrop || !previewCutout || isPreviewLoading}
            className="min-w-[200px]"
          >
            Continue to Batch Processing
            <ArrowRight className="ml-2 h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
};
Phase 4: Create BatchProcessingStep.tsx (The "Waiting Room")
Action: Create the new file src/components/BatchProcessingStep.tsx. This component will run the one-by-one loop.

File: src/components/BatchProcessingStep.tsx

TypeScript

import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Loader2, ArrowLeft, CheckCircle, AlertCircle, Wand2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { api } from "@/lib/api-client";
import { SubjectPlacement, compositeLayers, getImageDimensions } from "@/lib/canvas-utils";

// Define the subject type
interface Subject {
  name: string;
  originalData?: string;
  backgroundRemovedData?: string;
  size?: number;
  originalSize?: number;
}

interface MasterRules {
  placement: SubjectPlacement;
  padding: number;
  aspectRatio: string;
}

interface BatchProcessingStepProps {
  subjects: (File | Subject)[];
  backdrop: string;
  masterRules: MasterRules;
  isPreCut: boolean;
  onComplete: (results: Array<{ name: string; compositedData: string }>) => void;
  onBack: () => void;
}

interface ProcessedImage {
  name: string;
  compositedData: string;
}

interface FailedImage {
  name: string;
  error: string;
}

// Helper to read File as Data URL
const fileToDataUrl = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target?.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

// Client-side crop calculation
const calculateCanvasSize = (
  subjectW: number,
  subjectH: number,
  padding: number,
  aspectRatio: string
) => {
  const paddingPercent = padding / 100;
  
  // 1. Calculate padded subject size
  const paddedW = subjectW / (1 - paddingPercent * 2);
  const paddedH = subjectH / (1 - paddingPercent * 2);

  // 2. Determine final aspect ratio
  let finalAspectRatio: number;
  if (aspectRatio === '1:1') finalAspectRatio = 1;
  else if (aspectRatio === '4:3') finalAspectRatio = 4 / 3;
  else if (aspectRatio === '3:4') finalAspectRatio = 3 / 4;
  else finalAspectRatio = paddedW / paddedH; // 'original'

  // 3. Determine final canvas size
  let canvasW = paddedW;
  let canvasH = canvasW / finalAspectRatio;

  if (canvasH < paddedH) {
    canvasH = paddedH;
    canvasW = canvasH * finalAspectRatio;
  }
  
  return { width: Math.round(canvasW), height: Math.round(canvasH) };
};

export const BatchProcessingStep: React.FC<BatchProcessingStepProps> = ({
  subjects,
  backdrop,
  masterRules,
  isPreCut,
  onComplete,
  onBack,
}) => {
  const [progress, setProgress] = useState(0);
  const [currentStep, setCurrentStep] = useState("Initializing...");
  const [completedImages, setCompletedImages] = useState<ProcessedImage[]>([]);
  const [failedImages, setFailedImages] = useState<FailedImage[]>([]);
  const { toast } = useToast();

  useEffect(() => {
    processBatch();
  }, []);

  const processBatch = async () => {
    const results: ProcessedImage[] = [];
    const failed: FailedImage[] = [];

    for (let i = 0; i < subjects.length; i++) {
      const subject = subjects[i];
      const name = (subject as File).name || (subject as Subject).name;
      setCurrentStep(`Processing ${i + 1} of ${subjects.length}: ${name}`);
      
      try {
        // --- Step 1: Get Cutout Data ---
        let cleanCutoutData: string;
        if (isPreCut) {
          cleanCutoutData = await fileToDataUrl(subject as File);
        } else {
          // If we are post-BG-removal, the data is already here.
          cleanCutoutData = (subject as Subject).backgroundRemovedData || '';
        }
        if (!cleanCutoutData) throw new Error("Missing cutout data");
        
        // --- Step 2: Get Shadow Data ---
        const shadowResult = await api.addDropShadow({ 
          images: [{ name: name, data: cleanCutoutData }] 
        });
        const subjectWithShadow = shadowResult.images[0].shadowedData;
        if (!subjectWithShadow) throw new Error("Shadow generation failed");

        // --- Step 3: Calculate Crop ---
        const { width, height } = await getImageDimensions(subjectWithShadow);
        if (width === 0 || height === 0) throw new Error("Subject dimensions are zero");
        
        const outputCanvasSize = calculateCanvasSize(
          width,
          height,
          masterRules.padding,
          masterRules.aspectRatio
        );
        
        // --- Step 4: Final Composite ---
        const finalImage = await compositeLayers(
          backdrop,
          subjectWithShadow,
          cleanCutoutData, // Pass clean cutout for reflection
          masterRules.placement,
          outputCanvasSize,
          masterRules.padding // Pass padding for positioning
        );
        
        results.push({ name, compositedData: finalImage });
        setCompletedImages([...results]);

      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        console.error(`Failed to process ${name}:`, error);
        failed.push({ name, error: errorMessage });
        setFailedImages([...failed]);
        toast({
          title: `Failed: ${name}`,
          description: errorMessage,
          variant: "destructive",
        });
      }
      
      // Update progress
      setProgress(((i + 1) / subjects.length) * 100);
    }
    
    setCurrentStep("Batch processing complete!");
    // Wait 1 sec before transitioning to gallery
    setTimeout(() => {
      onComplete(results);
    }, 1000);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-background to-secondary/20 flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader className="text-center">
          <div className="flex items-center justify-center gap-2 text-primary mb-2">
            <Wand2 className="h-8 w-8" />
            <CardTitle className="text-2xl">Processing Batch</CardTitle>
          </div>
          <p className="text-muted-foreground">
            Please wait while we generate your images...
          </p>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="flex items-center justify-between text-sm">
              <span className="text-muted-foreground">{currentStep}</span>
              <span className="font-medium">{Math.round(progress)}%</span>
            </div>
            <Progress value={progress} className="h-2" />
          </div>

          <div className="flex items-center justify-center gap-2 text-primary">
            <Loader2 className="h-4 w-4 animate-spin" />
            <span className="font-medium">This may take several minutes. Please keep this tab open.</span>
          </div>

          { (completedImages.length > 0 || failedImages.length > 0) &&
            <div className="grid grid-cols-2 gap-4 max-h-48 overflow-y-auto bg-muted/50 p-4 rounded-lg">
              <div className="space-y-2">
                <h4 className="font-medium text-sm">Completed</h4>
                <ul className="text-xs space-y-1 text-green-600">
                  {completedImages.map((img) => (
                    <li key={img.name} className="flex items-center gap-1.5 truncate">
                      <CheckCircle className="h-3 w-3 shrink-0" />
                      <span>{img.name}</span>
                    </li>
                  ))}
                </ul>
              </div>
              <div className="space-y-2">
                <h4 className="font-medium text-sm">Failed</h4>
                <ul className="text-xs space-y-1 text-destructive">
                  {failedImages.map((img) => (
                    <li key={img.name} className="flex items-center gap-1.5 truncate">
                      <AlertCircle className="h-3 w-3 shrink-0" />
                      <span>{img.name}</span>
                    </li>
                  ))}
                </ul>
              </div>
            </div>
          }
          
          <Button variant="outline" onClick={onBack} className="w-full">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Setup (This will cancel the batch)
          </Button>
        </CardContent>
      </Card>
    </div>
  );
};
Phase 5: Fix canvas-utils.ts (Cropping & Reflection Bug)
Action: Replace the entire contents of src/lib/canvas-utils.ts with this. This is the final and most important fix.

File: src/lib/canvas-utils.ts

TypeScript

/**
 * Canvas utilities for AI commercial photo editing workflow
 */

export interface SubjectPlacement {
  x: number; // fraction of canvas width (0-1)
  y: number; // fraction of canvas height (0-1)
  scale: number; // Legacy, no longer used
}

/**
 * Utility to get image dimensions from data URL or blob URL
 */
export const getImageDimensions = (dataUrl: string): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      resolve({ width: img.naturalWidth, height: img.naturalHeight });
    };
    img.onerror = (err) => reject(new Error(`Failed to load image for dimensions: ${err}`));
    img.src = dataUrl;
  });
};

/**
 * Convert File to data URL
 */
export const fileToDataUrl = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      if (e.target?.result) {
        resolve(e.target.result as string);
      } else {
        reject('Failed to read file');
      }
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

/**
 * Helper function to load an image
 */
const loadImage = (src: string, name: string): Promise<HTMLImageElement> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = (err) => reject(new Error(`Failed to load ${name} image: ${err}`));
    img.src = src;
  });
};

/**
 * [REFACTORED] Composite backdrop, subject, and reflection
 * This function now implements Subject-Centric Cropping.
 * It creates a canvas of a specific size, then "zooms" the backdrop to fit.
 */
export const compositeLayers = async (
  backdropUrl: string,
  subjectWithShadowUrl: string,
  cleanSubjectUrl: string,
  placement: SubjectPlacement, // Contains the X/Y *floor* placement
  outputCanvasSize: { width: number; height: number },
  padding: number // Master padding (e.g., 20)
): Promise<string> => {
  
  console.log('üé® COMPOSITING: Starting Subject-Centric composite');
  
  try {
    const [backdrop, subjectWithShadow, cleanSubject] = await Promise.all([
      loadImage(backdropUrl, 'backdrop'),
      loadImage(subjectWithShadowUrl, 'subject with shadow'),
      loadImage(cleanSubjectUrl, 'clean subject')
    ]);

    const canvas = document.createElement('canvas');
    canvas.width = outputCanvasSize.width;
    canvas.height = outputCanvasSize.height;
    const ctx = canvas.getContext('2d');

    if (!ctx) {
      throw new Error('Failed to get canvas context');
    }

    console.log('Canvas created:', `${canvas.width}x${canvas.height}`);

    // --- 1. Draw Backdrop (Cropped/Zoomed) ---
    console.log('Drawing backdrop with "zoom" effect...');
    const canvasAspect = canvas.width / canvas.height;
    const backdropAspect = backdrop.width / backdrop.height;
    
    let drawW, drawH, drawX, drawY;

    // This logic mimics CSS "background-size: cover"
    if (backdropAspect > canvasAspect) { // Backdrop is wider than canvas
      drawH = canvas.height;
      drawW = backdrop.width * (canvas.height / backdrop.height);
      // Center horizontally on the user's X placement
      drawX = -(drawW - canvas.width) * placement.x; 
      drawY = 0;
    } else { // Backdrop is taller than canvas
      drawW = canvas.width;
      drawH = backdrop.height * (canvas.width / backdrop.width);
      drawX = 0;
      // Align the backdrop's "floor" (placement.y) with the canvas's "floor"
      const backdropFloorPx = backdrop.height * placement.y;
      const canvasFloorPx = canvas.height * placement.y;
      drawY = canvasFloorPx - (backdropFloorPx * (drawW / backdrop.width));
    }
    
    ctx.drawImage(backdrop, drawX, drawY, drawW, drawH);

    // --- 2. Calculate Subject Position (based on padding) ---
    const paddingPercent = padding / 100;
    const subjectAspectRatio = subjectWithShadow.naturalWidth / subjectWithShadow.naturalHeight;

    // Calculate the "box" the subject must fit in, based on padding
    const innerBoxW = canvas.width * (1 - paddingPercent * 2);
    const innerBoxH = canvas.height * (1 - paddingPercent * 2);
    
    let scaledWidth = innerBoxW;
    let scaledHeight = scaledWidth / subjectAspectRatio;
    
    if (scaledHeight > innerBoxH) {
      scaledHeight = innerBoxH;
      scaledWidth = scaledHeight * subjectAspectRatio;
    }
    
    // Position subject centered on X, and aligned to Y (floor)
    const dx = (canvas.width - scaledWidth) / 2;
    const dy = (canvas.height * placement.y) - scaledHeight * (1 - paddingPercent); // Aligns bottom of subject to floor
    
    console.log('Subject positioning:', {
      size: `${scaledWidth}x${scaledHeight}`,
      position: `${Math.round(dx)}, ${Math.round(dy)}`
    });

    // --- 3. Generate and Draw Reflection (THE FIX) ---
    console.log('ü™û Generating canvas-based reflection...');
    
    const reflectionHeight = scaledHeight * 0.6; // 60% height
    ctx.save();
    ctx.translate(dx, dy + scaledHeight); // Position *exactly* below subject
    ctx.scale(1, -1); // Flip vertically
    
    // Draw the *clean* subject (flipped)
    ctx.drawImage(cleanSubject, 0, 0, scaledWidth, reflectionHeight);
    
    // Apply fade gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, reflectionHeight);
    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.4)'); // Start at 40% opacity
    gradient.addColorStop(0.6, 'rgba(0, 0, 0, 0.1)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.globalCompositeOperation = 'destination-in';
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, scaledWidth, reflectionHeight);
    
    // Apply blur
    ctx.filter = 'blur(2px)';
    // We must draw onto itself to apply the filter
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(canvas, 
      dx, canvas.height - (dy + scaledHeight), scaledWidth, reflectionHeight, // Source (flipped area)
      0, 0, scaledWidth, reflectionHeight // Destination (in the save/restored context)
    );

    ctx.restore(); // Restore context (removes flip, blur, etc.)
    
    // --- 4. Draw Subject (with shadow) ---
    console.log('Drawing subject with shadow on top...');
    ctx.drawImage(subjectWithShadow, dx, dy, scaledWidth, scaledHeight);

    const finalDataUrl = canvas.toDataURL('image/png');
    console.log('Compositing complete.');
    
    return finalDataUrl;

  } catch (error) {
    console.error('Error during compositing:', error);
    throw error;
  }
};

// These functions are no longer used by the main workflow but can be kept
export const convertBlackToTransparent = async (imageDataUrl: string): Promise<string> => {
  // ... (existing code) ...
  return imageDataUrl; // Bypassing for now
};
export const applyMaskToImage = async (originalImageDataUrl: string, maskImageDataUrl: string): Promise<string> => {
  // ... (existing code) ...
  return originalImageDataUrl; // Bypassing for now
};
export const positionSubjectOnCanvas = async (
  subjectDataUrl: string, 
  targetWidth: number, 
  targetHeight: number, 
  placement: SubjectPlacement
): Promise<string> => {
  // ... (existing code) ...
  return subjectDataUrl; // Bypassing for now
};