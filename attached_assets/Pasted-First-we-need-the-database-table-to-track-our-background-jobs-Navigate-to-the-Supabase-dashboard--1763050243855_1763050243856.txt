First, we need the database table to track our background jobs.

Navigate to the Supabase dashboard for your project.

Go to the SQL Editor.

Click New query.

Paste the following code exactly and click RUN.

SQL

-- 1. Create a custom type for the job status
CREATE TYPE image_job_status AS ENUM ('pending', 'processing', 'completed', 'failed');

-- 2. Create the main image_jobs table
CREATE TABLE public.image_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    status image_job_status DEFAULT 'pending' NOT NULL,
    
    -- Input data from the client
    original_image_url TEXT, -- This will be the clean_cutout_data URL
    processing_options JSONB, -- Stores shadow/reflection settings
    
    -- Output data from the server
    final_image_url TEXT, -- This will be the SHADOWED_SUBJECT_URL
    error_message TEXT,
    
    -- Optional: for cleaning up old jobs
    expires_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '1 hour'
);

-- 3. Enable Row Level Security (RLS)
ALTER TABLE public.image_jobs ENABLE ROW LEVEL SECURITY;

-- 4. Create policies
CREATE POLICY "Users can create their own jobs"
ON public.image_jobs
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can read their own jobs"
ON public.image_jobs
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Server-side updates are allowed"
ON public.image_jobs
FOR UPDATE
USING (true)
WITH CHECK (true);
-- Note: In production, you'd lock this down to a service_role,
-- but for our server logic, this is fine.

-- 5. Create an index for faster lookups
CREATE INDEX idx_image_jobs_user_id_status ON public.image_jobs(user_id, status);
Why we're doing this: This table is the "brain" of our new asynchronous system. The client will create a row here, and the server will update it as it completes each step, allowing the client to poll for progress.