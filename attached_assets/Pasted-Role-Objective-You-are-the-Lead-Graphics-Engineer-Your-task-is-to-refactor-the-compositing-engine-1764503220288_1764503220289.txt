Role & Objective:You are the Lead Graphics Engineer. Your task is to refactor the compositing engine to ensure that the Live Canvas Preview (600px width) matches the Final Batch Export (3000px+ width) pixel-for-pixel.Current Problem:Effect Scale Mismatch: Hardcoded values (e.g., blur(9px)) look subtle on high-res exports but destroy the image on low-res previews.Geometric Scale Mismatch: The preview engine passes full-resolution subject dimensions to a low-resolution canvas, causing the subject to render enormously large (out of bounds).The Architectural Solution:We will implement a Reference Width Strategy. All spatial effects (blurs, offsets, shadows) will be calculated dynamically based on a reference standard of 3000px.$$\text{ScaledValue} = \text{BaseValue} \times \left( \frac{\text{CurrentCanvasWidth}}{3000} \right)$$Phase 1: src/lib/canvas-utils.ts (The Smart Scaling Engine)Task: Refactor the canvas utilities to use dynamic scaling for all effects.Define Constants & Helper:At the top of the file, define const REFERENCE_WIDTH = 3000;.Create a helper function getScaledValue(baseValue: number, currentWidth: number): number.Refactor applyDepthOfField:Input: Check the function signature; it already accepts width.Logic: Replace the hardcoded 'blur(9px)' with getScaledValue(9, width).Constraint: Ensure a minimum blur of 0.5px to preventing errors.Refactor drawReflection:Signature Change: Update the function to accept a new parameter: canvasWidth: number.Logic: Calculate blurRadius using getScaledValue(4, canvasWidth) (Base: 4px).Implementation: Pass this dynamic blur to generateSmartReflection.Refactor compositeLayersV2 (Final Assembly):Reflection Call: Pass layout.canvasWidth to the updated drawReflection function.Contact Shadow: Calculate the shadow blur using getScaledValue(8, layout.canvasWidth) (Base: 8px).Apply: Use this scaled value for ctx.filter.Phase 2: src/components/BackdropPositioning.tsx (Fixing the Preview)Task: Fix the "Giant Subject" bug by correctly projecting the subject into "Display Space".Locate renderCanvas:Inside the main render loop, you currently have width (Canvas Display Width) and backdropDimensions.w (Source Image Width).Implement Scene-to-Display Projection:Calculate the scale factor: const displayScale = width / backdropDimensions.w;Critical Step: Before calling computeCompositeLayout, scale the subject's natural dimensions:TypeScriptconst displaySubjectW = subjectImgRef.current.naturalWidth * displayScale;
const displaySubjectH = subjectImgRef.current.naturalHeight * displayScale;
Update Layout Calculation:Pass these scaled dimensions (displaySubjectW, displaySubjectH) into computeCompositeLayout instead of the natural dimensions.This ensures the layout engine calculates positions relative to the 600px preview canvas, not the 3000px source image.Phase 3: Agentic Verification & Testing ProtocolCrucial: Do not simply apply code. You must verify the logic mentally before confirming.Step 1: Verify Blur ScalingScenario: User uploads a 3000px backdrop. Preview width is 600px.Check: applyDepthOfField is called with width=600.Math: 9 * (600 / 3000) = 1.8px.Result: The preview shows a 1.8px blur. This visually matches the 9px blur on the full image. (PASS)Step 2: Verify Subject PositioningScenario: Backdrop is 3000x3000px. Canvas is 600x600px. Subject is 1500px wide.Old Logic: Passes 1500px subject to 600px canvas. Layout centers it at x = 300 - 750 = -450. (FAIL - Out of bounds)New Logic: Scales subject: 1500 * (600/3000) = 300px.New Layout: Centers 300px subject on 600px canvas. x = 300 - 150 = 150. (PASS - Perfectly centered)Step 3: Verify Reference ConsistencyCheck: Ensure REFERENCE_WIDTH is defined once and used consistently for Background Blur, Reflection Blur, and Contact Shadow Blur.Execution Instructions for ReplitRead src/lib/canvas-utils.ts and apply the getScaledValue helper and Reference Width logic first.Update the effect functions (applyDepthOfField, drawReflection, etc.) to use this helper.Read src/components/BackdropPositioning.tsx.Refactor the renderCanvas function to implement the displayScale logic defined in Phase 2.Console Logging: Add a temporary log in renderCanvas to confirm the scale factor:console.log('Scaling Factor:', displayScale, 'Display Subject Width:', displaySubjectW);GOAL: The user should see a preview that looks exactly like a miniature version of the final downloadable image, with no "zoomed in" artifacts or "washed out" excessive blurring.